"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBoundedIndex = exports.getDefaultSlideIndex = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.isSlideVisible = void 0;
const default_controls_1 = require("./default-controls");
const types_1 = require("./types");
const isSlideVisible = (currentSlide, indexToCheck, slidesToShow, cellAlign) => {
    // The addition or subtraction of constants (1 , 0.5) in the following
    // calculations are accounting for the fact that a slide will be visible even
    // after the position associated with its index is off-screen. For example,
    // with cellAlign="left", slidesToShow=1 and indexToCheck=0,
    // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1
    // will be visible at the same time, even though the position we associate
    // with index 0, its leftmost edge, is off-screen.
    if (cellAlign === types_1.Alignment.Left) {
        return (indexToCheck < currentSlide + slidesToShow &&
            indexToCheck > currentSlide - 1);
    }
    if (cellAlign === types_1.Alignment.Center) {
        return ((indexToCheck > currentSlide - slidesToShow / 2 - 0.5 &&
            indexToCheck <= currentSlide) ||
            (indexToCheck > currentSlide &&
                indexToCheck < currentSlide + slidesToShow / 2 + 0.5));
    }
    if (cellAlign === types_1.Alignment.Right) {
        return (indexToCheck < currentSlide + 1 &&
            indexToCheck > currentSlide - slidesToShow);
    }
    return false;
};
exports.isSlideVisible = isSlideVisible;
const getNextMoveIndex = (scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) => {
    if (wrapAround) {
        return currentSlide + slidesToScroll;
    }
    // Quit early if we're already as far right as we can go
    if (currentSlide >= slideCount - 1 ||
        (cellAlign === types_1.Alignment.Left && currentSlide >= slideCount - slidesToShow)) {
        return currentSlide;
    }
    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Left) {
        return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);
    }
    return Math.min(currentSlide + slidesToScroll, slideCount - 1);
};
exports.getNextMoveIndex = getNextMoveIndex;
const getPrevMoveIndex = (scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) => {
    if (wrapAround) {
        return currentSlide - slidesToScroll;
    }
    // Quit early if we're already as far left as we can go
    if (currentSlide <= 0 ||
        (cellAlign === types_1.Alignment.Right && currentSlide <= slidesToShow - 1)) {
        return currentSlide;
    }
    if (scrollMode === types_1.ScrollMode.remainder && cellAlign === types_1.Alignment.Right) {
        return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);
    }
    return Math.max(currentSlide - slidesToScroll, 0);
};
exports.getPrevMoveIndex = getPrevMoveIndex;
const getDefaultSlideIndex = (slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) => {
    if (slideIndex !== undefined) {
        return slideIndex;
    }
    const dotIndexes = (0, default_controls_1.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);
    return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];
};
exports.getDefaultSlideIndex = getDefaultSlideIndex;
/**
 * Boils down an unbounded index (-Infinity < index < Infinity) to a bounded one
 * (0 â‰¤ index < slideCount)
 */
const getBoundedIndex = (rawIndex, slideCount) => {
    return ((rawIndex % slideCount) + slideCount) % slideCount;
};
exports.getBoundedIndex = getBoundedIndex;
//# sourceMappingURL=utils.js.map