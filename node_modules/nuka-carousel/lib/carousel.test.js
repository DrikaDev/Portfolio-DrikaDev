"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("@testing-library/react");
const carousel_1 = __importDefault(require("./carousel"));
// Fake timers using Jest
beforeEach(() => {
    jest.useFakeTimers();
});
// Running all pending timers and switching to real timers using Jest
afterEach(() => {
    jest.runOnlyPendingTimers();
    jest.useRealTimers();
});
/**
 * Mock dimensions for the carousel for calculations where carousel dimensions
 * are used, such as with dragging thresholds
 */
const createCarouselRefWithMockedDimensions = ({ defaultWidth = 600 } = {}) => {
    let refValue = null;
    const widthGetterMock = jest.fn(() => defaultWidth);
    const carouselRef = Object.create({}, {
        current: {
            get: () => refValue,
            set(newValue) {
                refValue = newValue;
                if (refValue) {
                    Object.defineProperty(refValue, 'offsetWidth', {
                        get: widthGetterMock,
                    });
                }
            },
        },
    });
    return { ref: carouselRef, widthGetterMock };
};
describe('Carousel', () => {
    const renderCarousel = (_a = {}) => {
        var { slideCount = 5 } = _a, props = __rest(_a, ["slideCount"]);
        return (0, react_1.render)((0, jsx_runtime_1.jsx)(carousel_1.default, Object.assign({}, props, { children: [...Array(slideCount)].map((_, index) => ((0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide ${index}` }, index))) })));
    };
    it('autoplays at the right rate', () => {
        const beforeSlide = jest.fn();
        const afterSlide = jest.fn();
        const speed = 500;
        const autoplayInterval = 1000;
        const slideCount = 2;
        renderCarousel({
            slideCount,
            autoplay: true,
            autoplayInterval,
            speed,
            wrapAround: true,
            beforeSlide,
            afterSlide,
        });
        expect(beforeSlide).toHaveBeenCalledTimes(0);
        expect(afterSlide).toHaveBeenCalledTimes(0);
        // autoplay initiated, waiting for first interval
        (0, react_1.act)(() => {
            jest.advanceTimersByTime(autoplayInterval);
        });
        expect(beforeSlide).toHaveBeenCalledTimes(1);
        expect(afterSlide).toHaveBeenCalledTimes(0);
        const checkTimingCycle = (timesMoved) => {
            // Animation begins, and next autoplay timeout set up
            (0, react_1.act)(() => {
                jest.advanceTimersByTime(speed);
            });
            // Animation completes
            expect(beforeSlide).toHaveBeenCalledTimes(timesMoved);
            expect(afterSlide).toHaveBeenCalledTimes(timesMoved);
            expect(afterSlide).toHaveBeenLastCalledWith(timesMoved % slideCount);
            (0, react_1.act)(() => {
                jest.advanceTimersByTime(autoplayInterval - speed);
            });
            // autoplay timeout triggers
            expect(beforeSlide).toHaveBeenCalledTimes(timesMoved + 1);
            expect(afterSlide).toHaveBeenCalledTimes(timesMoved);
        };
        checkTimingCycle(1);
        checkTimingCycle(2);
        checkTimingCycle(3);
    });
    it('omits slides whose children are falsy', () => {
        const { container } = (0, react_1.render)((0, jsx_runtime_1.jsxs)(carousel_1.default, { children: [(0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 1` }), (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 2` }), false && (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 3` }), null, (0, jsx_runtime_1.jsx)("img", { src: "#", alt: `slide 5` })] }));
        expect(container.getElementsByClassName('slide').length).toBe(3);
    });
    it('can be controlled with the keyboard', () => {
        const beforeSlide = jest.fn();
        const keyCodeConfig = {
            nextSlide: [39],
            previousSlide: [37],
            firstSlide: [81],
            lastSlide: [69],
            pause: [32],
        };
        const slideCount = 8;
        renderCarousel({
            enableKeyboardControls: true,
            keyCodeConfig,
            slideCount,
            beforeSlide,
        });
        const carouselFrame = react_1.screen.getByRole('region');
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.nextSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(0, 1);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.nextSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(1, 2);
        react_1.fireEvent.keyDown(carouselFrame, {
            keyCode: keyCodeConfig.previousSlide[0],
        });
        expect(beforeSlide).toHaveBeenLastCalledWith(2, 1);
        react_1.fireEvent.keyDown(carouselFrame, {
            keyCode: keyCodeConfig.previousSlide[0],
        });
        expect(beforeSlide).toHaveBeenLastCalledWith(1, 0);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.lastSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(0, slideCount - 1);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.firstSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(slideCount - 1, 0);
    });
    it('detects user-triggered navigation', () => {
        const beforeSlide = jest.fn();
        const onUserNavigation = jest.fn();
        const keyCodeConfig = {
            nextSlide: [39],
            previousSlide: [37],
            firstSlide: [81],
            lastSlide: [69],
            pause: [32],
        };
        const autoplayInterval = 3000;
        const slideCount = 8;
        renderCarousel({
            enableKeyboardControls: true,
            autoplay: true,
            autoplayInterval,
            keyCodeConfig,
            innerRef: createCarouselRefWithMockedDimensions().ref,
            slideCount,
            beforeSlide,
            onUserNavigation,
        });
        expect(onUserNavigation).toHaveBeenCalledTimes(0);
        // Let enough time pass that autoplay triggers navigation
        (0, react_1.act)(() => {
            jest.advanceTimersByTime(autoplayInterval);
        });
        // Make sure the navigation happened, but did not trigger the
        // `onUserNavigation` callback (because it wasn't user-initiated)
        expect(onUserNavigation).toHaveBeenCalledTimes(0);
        expect(beforeSlide).toHaveBeenLastCalledWith(0, 1);
        const carouselFrame = react_1.screen.getByRole('region');
        // Simulating keyboard shortcut use to navigate
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.nextSlide[0] });
        expect(beforeSlide).toHaveBeenLastCalledWith(1, 2);
        expect(onUserNavigation).toHaveBeenCalledTimes(1);
        react_1.fireEvent.keyDown(carouselFrame, {
            keyCode: keyCodeConfig.previousSlide[0],
        });
        expect(onUserNavigation).toHaveBeenCalledTimes(2);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.lastSlide[0] });
        expect(onUserNavigation).toHaveBeenCalledTimes(3);
        react_1.fireEvent.keyDown(carouselFrame, { keyCode: keyCodeConfig.firstSlide[0] });
        expect(onUserNavigation).toHaveBeenCalledTimes(4);
        // Simulating clicks on default controls to navigate
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /next/ }));
        expect(onUserNavigation).toHaveBeenCalledTimes(5);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /prev/ }));
        expect(onUserNavigation).toHaveBeenCalledTimes(6);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /slide 2/ }));
        expect(onUserNavigation).toHaveBeenCalledTimes(7);
        // Simulating drag to navigate
        react_1.fireEvent.mouseDown(carouselFrame, { clientX: 100 });
        react_1.fireEvent.mouseMove(carouselFrame, { clientX: 100 });
        jest.advanceTimersByTime(100);
        react_1.fireEvent.mouseMove(carouselFrame, { clientX: 700 });
        react_1.fireEvent.mouseUp(carouselFrame, { clientX: 700 });
        expect(onUserNavigation).toHaveBeenCalledTimes(8);
        // Simulating swipe to navigate
        react_1.fireEvent.touchStart(carouselFrame, { touches: [{ pageX: 700 }] });
        react_1.fireEvent.touchMove(carouselFrame, { touches: [{ pageX: 700 }] });
        jest.advanceTimersByTime(100);
        react_1.fireEvent.touchMove(carouselFrame, { touches: [{ pageX: 100 }] });
        react_1.fireEvent.touchEnd(carouselFrame, { touches: [{ pageX: 100 }] });
        expect(onUserNavigation).toHaveBeenCalledTimes(9);
        // Should not be triggering navigation callback when dragging didn't trigger navigation
        react_1.fireEvent.mouseDown(carouselFrame, { clientX: 100 });
        react_1.fireEvent.mouseMove(carouselFrame, { clientX: 100 });
        jest.advanceTimersByTime(10);
        react_1.fireEvent.mouseMove(carouselFrame, { clientX: 105 });
        react_1.fireEvent.mouseUp(carouselFrame, { clientX: 105 });
        expect(onUserNavigation).toHaveBeenCalledTimes(9);
    });
    it('calls default control callbacks when interacted with', () => {
        const beforeSlide = jest.fn();
        const nextButtonOnClick = jest.fn();
        const prevButtonOnClick = jest.fn();
        const pagingDotsOnClick = jest.fn();
        const slideCount = 8;
        renderCarousel({
            slideCount,
            beforeSlide,
            defaultControlsConfig: {
                nextButtonOnClick,
                prevButtonOnClick,
                pagingDotsOnClick,
            },
        });
        // Simulating clicks on default controls to navigate
        expect(nextButtonOnClick).toHaveBeenCalledTimes(0);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /next/ }));
        expect(nextButtonOnClick).toHaveBeenCalledTimes(1);
        expect(prevButtonOnClick).toHaveBeenCalledTimes(0);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /prev/ }));
        expect(prevButtonOnClick).toHaveBeenCalledTimes(1);
        expect(pagingDotsOnClick).toHaveBeenCalledTimes(0);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /slide 2/ }));
        expect(pagingDotsOnClick).toHaveBeenCalledTimes(1);
        // Check that calling preventDefault in the custom callback will stop the
        // default behavior (navigation) before it happens
        const preventDefault = (event) => event.preventDefault();
        nextButtonOnClick.mockImplementation(preventDefault);
        prevButtonOnClick.mockImplementation(preventDefault);
        pagingDotsOnClick.mockImplementation(preventDefault);
        expect(beforeSlide).toHaveBeenCalledTimes(3);
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /next/ }));
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /prev/ }));
        react_1.fireEvent.click(react_1.screen.getByRole('button', { name: /slide 2/ }));
        expect(beforeSlide).toHaveBeenCalledTimes(3);
    });
});
//# sourceMappingURL=carousel.test.js.map