"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSlideVisible = exports.getPrevMoveIndex = exports.getNextMoveIndex = exports.getDefaultSlideIndex = exports.getBoundedIndex = void 0;

var _defaultControls = require("./default-controls");

var _types = require("./types");

var isSlideVisible = function isSlideVisible(currentSlide, indexToCheck, slidesToShow, cellAlign) {
  // The addition or subtraction of constants (1 , 0.5) in the following
  // calculations are accounting for the fact that a slide will be visible even
  // after the position associated with its index is off-screen. For example,
  // with cellAlign="left", slidesToShow=1 and indexToCheck=0,
  // if the currentSlide is set to 0.99, both (a sliver of) slide 0 and slide 1
  // will be visible at the same time, even though the position we associate
  // with index 0, its leftmost edge, is off-screen.
  if (cellAlign === _types.Alignment.Left) {
    return indexToCheck < currentSlide + slidesToShow && indexToCheck > currentSlide - 1;
  }

  if (cellAlign === _types.Alignment.Center) {
    return indexToCheck > currentSlide - slidesToShow / 2 - 0.5 && indexToCheck <= currentSlide || indexToCheck > currentSlide && indexToCheck < currentSlide + slidesToShow / 2 + 0.5;
  }

  if (cellAlign === _types.Alignment.Right) {
    return indexToCheck < currentSlide + 1 && indexToCheck > currentSlide - slidesToShow;
  }

  return false;
};

exports.isSlideVisible = isSlideVisible;

var getNextMoveIndex = function getNextMoveIndex(scrollMode, wrapAround, currentSlide, slideCount, slidesToScroll, slidesToShow, cellAlign) {
  if (wrapAround) {
    return currentSlide + slidesToScroll;
  } // Quit early if we're already as far right as we can go


  if (currentSlide >= slideCount - 1 || cellAlign === _types.Alignment.Left && currentSlide >= slideCount - slidesToShow) {
    return currentSlide;
  }

  if (scrollMode === _types.ScrollMode.remainder && cellAlign === _types.Alignment.Left) {
    return Math.min(currentSlide + slidesToScroll, slideCount - slidesToShow);
  }

  return Math.min(currentSlide + slidesToScroll, slideCount - 1);
};

exports.getNextMoveIndex = getNextMoveIndex;

var getPrevMoveIndex = function getPrevMoveIndex(scrollMode, wrapAround, currentSlide, slidesToScroll, slidesToShow, cellAlign) {
  if (wrapAround) {
    return currentSlide - slidesToScroll;
  } // Quit early if we're already as far left as we can go


  if (currentSlide <= 0 || cellAlign === _types.Alignment.Right && currentSlide <= slidesToShow - 1) {
    return currentSlide;
  }

  if (scrollMode === _types.ScrollMode.remainder && cellAlign === _types.Alignment.Right) {
    return Math.max(currentSlide - slidesToScroll, slidesToShow - 1);
  }

  return Math.max(currentSlide - slidesToScroll, 0);
};

exports.getPrevMoveIndex = getPrevMoveIndex;

var getDefaultSlideIndex = function getDefaultSlideIndex(slideIndex, slideCount, slidesToShow, slidesToScroll, cellAlign, autoplayReverse, scrollMode) {
  if (slideIndex !== undefined) {
    return slideIndex;
  }

  var dotIndexes = (0, _defaultControls.getDotIndexes)(slideCount, slidesToScroll, scrollMode, slidesToShow, false, cellAlign);
  return autoplayReverse ? dotIndexes[dotIndexes.length - 1] : dotIndexes[0];
};
/**
 * Boils down an unbounded index (-Infinity < index < Infinity) to a bounded one
 * (0 â‰¤ index < slideCount)
 */


exports.getDefaultSlideIndex = getDefaultSlideIndex;

var getBoundedIndex = function getBoundedIndex(rawIndex, slideCount) {
  return (rawIndex % slideCount + slideCount) % slideCount;
};

exports.getBoundedIndex = getBoundedIndex;